---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter* (Mac OS X) or *Ctrl+Shift+Enter* (Windows). 

## 1. Viterbi algorithm in HMM.

Let `transMtx` be a $n\times n$ matrix, where $n$ is the number of possible state in HMM, representing a transition matrix from state $i$ (row) to $j$ (column). Let `emisMtx` to be a $n \times m$ matrix, where $m$ is the number of possible observations. Let `pi` be a size $n$ vector representing the initial probabilties of each state. Finally, let `obs` be a size $T$ vector representing the possible observations in $\{0,\ldots,m-1\}$.

Below we implement a Viterbi algoirithm that returns the maximum likelihood and the ML states correspinding to the observed data. We will implement two versions - one with recursive calls, and one with loop.s 

```{Rcpp}
#include <Rcpp.h>
using namespace std;
using namespace Rcpp;

double viterbiLoop(IntegerVector& obs, NumericMatrix& transMtx,
                   NumericMatrix& emisMtx, NumericVector& pi,
                   NumericMatrix& delta, IntegerMatrix& phi) {
  int T = (int)obs.size();  
  int ns = (int)pi.size();
  for(int i=0; i < ns; ++i) 
    delta(i,0) = pi(i) * emisMtx(i, obs[0]);
  for(int t=1; t < T; ++t) {
    for(int i=0; i < ns; ++i) {
      for(int j=0; j < ns; ++j) {
        double v = delta(j,t-1) * transMtx(j, i);
        if ( v > delta(i,t) ) {
          delta(i,t) = v;
          phi(i,t) = j;
        }
      }
      delta(i,t) *= emisMtx(i, obs[t]);
    }
  }
  double ml = -1;
  for(int i=0; i < ns; ++i) {
    if ( delta(i,T-1) > ml ) ml = delta(i,T-1);
  }
  return ml;
}

double viterbiDP(IntegerVector& obs, NumericMatrix& transMtx,
               NumericMatrix& emisMtx, NumericVector& pi,
               int t, int s, 
               NumericMatrix& delta, IntegerMatrix& phi) {
  if ( delta(s, t) < 0 ) {
    if ( t == 0 ) delta(s, t) = pi[s]; 
    else {
      int ns = (int)pi.size();
      for(int i=0; i < ns; ++i) {
        double v = viterbiDP(obs, transMtx, emisMtx, pi, t-1, i, delta, phi) * transMtx(i, s);
        if ( delta(s, t) < v ) {
          delta(s, t) = v;
          phi(s, t) = i;
        } 
      }
    }
    delta(s, t) *= emisMtx(s, obs[t]);
  }
  return delta(s,t);
}

// [[Rcpp::export]]
List viterbiHMM(IntegerVector obs, NumericMatrix transMtx, NumericMatrix emisMtx, NumericVector pi) {
  int T = (int)obs.size();  
  int ns = (int)pi.size();
  NumericMatrix delta(ns, T);
  IntegerMatrix phi(ns, T);
  std::fill(delta.begin(), delta.end(), -1);
  
  double ml = -1;
  IntegerVector paths(T);
  for(int i=0; i < ns; ++i) {
    double v = viterbiDP(obs, transMtx, emisMtx, pi, T-1, i, delta, phi);
    if ( ml < v ) {
      ml = v;
      paths[T-1] = i;
    }
  }  
  for(int i=T-1; i > 0; --i) 
    paths[i-1] = phi(paths[i],i);
  return ( List::create(Named("ML") = ml,
                        Named("path") = paths,
                        Named("delta") = delta,
                        Named("phi") = phi
  ) );
}

// [[Rcpp::export]]
List viterbiHMM2(IntegerVector obs, NumericMatrix transMtx, NumericMatrix emisMtx, NumericVector pi) {
  int T = (int)obs.size();  
  int ns = (int)pi.size();
  if ( ( ns != transMtx.ncol() ) || ( ns != transMtx.nrow() ) )
    stop("transMtx must be square and have same dimension with pi");
  if ( ns != emisMtx.nrow() )
    stop("emisMtx must have the same number of rows to transMtx");

  NumericMatrix delta(ns, T);
  IntegerMatrix phi(ns, T);
  std::fill(delta.begin(), delta.end(), -1);
  
  viterbiLoop(obs, transMtx, emisMtx, pi, delta, phi);
  double ml = -1;
  IntegerVector paths(T);
  for(int i=0; i < ns; ++i) {
    if ( ml < delta(i,T-1) ) {
      ml = delta(i,T-1);
      paths[T-1] = i;
    }
  }  
  for(int i=T-1; i > 0; --i) {
    paths[i-1] = phi(paths[i],i);
  }
  
  return ( List::create(Named("ML") = ml,
                        Named("path") = paths,
                        Named("delta") = delta,
                        Named("phi") = phi
  ) );
}
```

```{r}
A <- matrix(c(0.8, 0.2, 0.4, 0.6),2,2,byrow=TRUE)
B <- matrix(c(0.88, 0.10, 0.02, 0.10, 0.60, 0.30),2,3,byrow=TRUE)
pi <- c(0.7,0.3)
obs <- c(0,2,1) # SUNNY, SUNNY, RAINY, RAINY, CLOUDY

viterbiHMM(obs, A, B, pi)
viterbiHMM(c(0,0,2,2,1), A, B, pi)
viterbiHMM(c(0,0,1,2,2), A, B, pi)
viterbiHMM2(obs, A, B, pi)
```

## 2. Forward-backward algorithm in HMM.

Next, we implement a forward-backward algorithm using a loop implementation.

```{Rcpp}
#include <Rcpp.h>
using namespace std;
using namespace Rcpp;

void forwardLoop(IntegerVector& obs, NumericMatrix& transMtx,
               NumericMatrix& emisMtx, NumericVector& pi,
               NumericMatrix& alpha) {
  int T = (int)obs.size();  
  int ns = (int)pi.size();
  
  for(int i=0; i < ns; ++i) 
    alpha(i,0) = pi(i) * emisMtx(i, obs[0]);
  
  for(int t=1; t < T; ++t) {
    for(int i=0; i < ns; ++i) {
      alpha(i,t) = 0;
      for(int j=0; j < ns; ++j) 
        alpha(i,t) += ( alpha(j,t-1) * transMtx(j,i) );
      alpha(i,t) *= emisMtx(i, obs[t]); // why did I do this?
    }
  }
}

void backwardLoop(IntegerVector& obs, NumericMatrix& transMtx,
               NumericMatrix& emisMtx, NumericVector& pi,
               NumericMatrix& beta) {
  int T = (int)obs.size();  
  int ns = (int)pi.size();
  
  for(int i=0; i < ns; ++i) 
    beta(i,T-1) = 1;
  
  for(int t=T-2; t >=0; --t) {
    for(int i=0; i < ns; ++i) {
      beta(i,t) = 0;
      for(int j=0; j < ns; ++j) 
        beta(i,t) += ( beta(j,t+1) * transMtx(i,j) * emisMtx(j, obs[t+1]) );
    }
  }
}

// [[Rcpp::export]]
NumericMatrix forwardBackwardHMM(IntegerVector obs, NumericMatrix transMtx, NumericMatrix emisMtx, NumericVector pi) {
  int T = (int)obs.size();  
  int ns = (int)pi.size();
  NumericMatrix alpha(ns, T);
  NumericMatrix beta(ns, T);
  
  forwardLoop(obs, transMtx, emisMtx, pi, alpha);
  backwardLoop(obs, transMtx, emisMtx, pi, beta);
  NumericMatrix condProb(ns, T);
  
  for(int t=0; t < T; ++t) {
    double sum = 0;
    
    for(int i=0; i < ns; ++i) 
      sum += ( alpha(i,t) * beta(i,t) );
    for(int i=0; i < ns; ++i) 
      condProb(i,t) = alpha(i,t) * beta(i,t) / sum;
  }
  return condProb;
}
```

```{r}
A <- matrix(c(0.8, 0.2, 0.4, 0.6),2,2,byrow=TRUE)
B <- matrix(c(0.88, 0.10, 0.02, 0.10, 0.60, 0.30),2,3,byrow=TRUE)
pi <- c(0.7,0.3)
forwardBackwardHMM(c(0,2,1), A, B, pi)
forwardBackwardHMM(c(0,0), A, B, pi)
```